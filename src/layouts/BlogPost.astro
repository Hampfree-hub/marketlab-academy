---
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';
import ScrollTop from '../components/ScrollTop.astro';
import RelatedPosts from '../components/RelatedPosts.astro';
import Breadcrumb from '../components/Breadcrumb.astro';
import Banner from '../components/Banner.astro';
import FAQ from '../components/FAQ.astro';
import Disclaimer from '../components/Disclaimer.astro';
import { getLangFromUrl, useTranslations, useTranslatedPath } from '../i18n/utils';

interface Props {
	title: string;
	description: string;
	metaOgTitle?: string; // OG заголовок для соцсетей (опционально)
	readingTime?: number; // Время чтения в минутах (вычисляется автоматически)
	pubDate?: Date;
	updatedDate?: Date;
	heroImage?: string;
	bannerImage?: string;
	category?: string;
	tags?: string[];
	faq?: { q: string; a: string }[];
	postId?: string;
	headings?: { depth: number; slug: string; text: string }[];
	customBreadcrumbs?: { label: string; href?: string }[];
}

const { title, description, metaOgTitle, readingTime, pubDate, updatedDate, heroImage, bannerImage, category, tags, faq, postId, headings, customBreadcrumbs } = Astro.props;
const displayImage = heroImage || bannerImage;

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
const translatePath = useTranslatedPath(lang);

const titleWords = title.split(/\s+/).length;
const headingClass = titleWords <= 5 ? 'brutal' : 'long';

// Содержание на разных языках
const tocTitle = {
	ru: 'Содержание',
	en: 'Table of Contents',
	es: 'Tabla de Contenidos'
}[lang] || 'Содержание';

const breadcrumbItems: Array<{ label: string; href?: string }> = customBreadcrumbs || (() => {
	const items: Array<{ label: string; href?: string }> = [
		{ label: t('nav.library'), href: translatePath('library') }
	];
	
	// Добавляем категорию в хлебные крошки, если она указана
	if (category) {
		const catLabel = t(`cat.${category}` as any);
		if (catLabel) {
			items.push({ label: catLabel, href: `${translatePath('library')}?cat=${category}` });
		}
	}
	
	items.push({ label: title });
	return items;
})();
---

<html lang={lang}>
	<head>
		<BaseHead title={title} description={description} metaOgTitle={metaOgTitle} image={displayImage} />
	</head>

	<body>
		<Header />
		<main class="container">
			<div class="layout-grid">
				<article class="fade-in">
					<Breadcrumb items={breadcrumbItems} />
					
					{pubDate && (
						<div class="meta" style="margin-bottom: var(--space-1); display: flex; gap: var(--space-2); align-items: center; flex-wrap: wrap;">
							<FormattedDate date={pubDate} />
							{updatedDate && <span> • UPDATED: <FormattedDate date={updatedDate} /></span>}
							{readingTime && readingTime > 0 && (
								<span> • {readingTime} {lang === 'ru' ? 'мин' : lang === 'en' ? 'min' : 'min'} {lang === 'ru' ? 'чтения' : lang === 'en' ? 'read' : 'lectura'}</span>
							)}
						</div>
					)}

					<Banner 
						title={title} 
						subtitle={description}
						category={category} 
						type="full" 
						className="hero-img"
					/>

					<div class="prose">
						<slot />
					</div>

					<div style="margin-top: var(--space-10);">
						<Disclaimer />
					</div>

					{faq && faq.length > 0 && (
						<FAQ items={faq} />
					)}

					<div class="article-footer" style="margin-top: var(--space-6); display: flex; flex-direction: column; gap: var(--space-6);">
						{tags && tags.length > 0 && (
							<div class="tags-section">
								<div class="section-label" style="margin-bottom: var(--space-2);">{t('library.filter') || 'TAGS:'}</div>
								<div class="tags-container" style="display: flex; gap: var(--space-2); flex-wrap: wrap;">
									{tags.map(tag => (
										<a href={`${translatePath('library')}?search=${tag}`} class="tag-btn" style="text-decoration: none;">
											#{tag}
										</a>
									))}
								</div>
							</div>
						)}

						{postId && (
							<div class="nes-container with-title">
								<p class="title">{t('home.recent_label') || 'RELATED'}</p>
								<RelatedPosts currentPostId={postId} category={category} />
							</div>
						)}
					</div>
				</article>

				<aside class="toc-sticky">
					<div class="nes-container with-title">
						<p class="title">{tocTitle}</p>
					<ul class="toc-list">
						{headings?.map((heading) => {
							// Используем CSS переменные для отступов (кратно 8px)
							// depth=2: 32px (--space-4), depth=3: 40px (--space-5), depth=4: 48px (--space-6)
							const paddingLeft = heading.depth === 2 ? 'var(--space-4)' : 
							                   heading.depth === 3 ? 'var(--space-5)' : 
							                   heading.depth === 4 ? 'var(--space-6)' : 
							                   `calc(var(--space-2) * ${heading.depth})`;
							return (
								<li class="toc-item" style={`padding-left: ${paddingLeft}`}>
									<a href={`#${heading.slug}`}>{heading.text}</a>
								</li>
							);
						})}
					</ul>
					</div>
				</aside>
			</div>

			<ScrollTop />
		</main>
		<Footer />

		<script is:inline>
			// Interactive TOC Highlighting - оптимизировано для предотвращения дёргания
			const observerOptions = {
				root: null,
				rootMargin: '0px 0px -80% 0px',
				threshold: 0
			};

			let currentActiveLink = null;
			let rafId = null;

			const updateActiveLink = (id) => {
				if (rafId) {
					cancelAnimationFrame(rafId);
				}
				
				rafId = requestAnimationFrame(() => {
					const activeLink = document.querySelector(`.toc-item a[href="#${id}"]`);
					
					// Обновляем только если активная ссылка изменилась
					if (activeLink && activeLink !== currentActiveLink) {
						// Удаляем класс у предыдущей активной ссылки
						if (currentActiveLink) {
							currentActiveLink.classList.remove('active');
						}
						// Добавляем класс к новой активной ссылке
						activeLink.classList.add('active');
						currentActiveLink = activeLink;
					}
					
					rafId = null;
				});
			};

			const observer = new IntersectionObserver((entries) => {
				// Находим первый видимый заголовок (ближайший к верху viewport)
				const visibleHeaders = entries
					.filter(entry => entry.isIntersecting)
					.map(entry => ({
						element: entry.target,
						top: entry.boundingClientRect.top
					}))
					.sort((a, b) => a.top - b.top);

				if (visibleHeaders.length > 0) {
					const id = visibleHeaders[0].element.getAttribute('id');
					if (id) {
						updateActiveLink(id);
					}
				}
			}, observerOptions);

			// Observe all headers inside .prose
			document.querySelectorAll('.prose h2, .prose h3').forEach((header) => {
				observer.observe(header);
			});
		</script>
	</body>
</html>
