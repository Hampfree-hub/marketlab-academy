---
import { getCollection } from 'astro:content';
import BaseHead from '../../../components/BaseHead.astro';
import Header from '../../../components/Header.astro';
import Footer from '../../../components/Footer.astro';
import Breadcrumb from '../../../components/Breadcrumb.astro';
import { SITE_TITLE } from '../../../consts';
import FormattedDate from '../../../components/FormattedDate.astro';
import ScrollTop from '../../../components/ScrollTop.astro';
import Banner from '../../../components/Banner.astro';
import PixelIcon from '../../../components/ui/PixelIcon.astro';
import '../../../styles/components/blog-index.css';
import { ui } from '../../../i18n/ui';
import { useTranslations, useTranslatedPath } from '../../../i18n/utils';

export async function getStaticPaths() {
  return [
    { params: { lang: 'ru' } },
    { params: { lang: 'en' } },
    { params: { lang: 'es' } },
  ];
}

const { lang } = Astro.params;
const t = useTranslations(lang as keyof typeof ui);
const translatePath = useTranslatedPath(lang as keyof typeof ui);

// Fetch only posts for current language
const collectionName = `blog-${lang}` as 'blog-ru' | 'blog-en' | 'blog-es';
const posts = await getCollection(collectionName).catch((err) => {
	console.error(`Error loading posts for ${collectionName}:`, err);
	return [];
});
const sortedPosts = posts.sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

// Debug: Log posts count
if (import.meta.env.DEV) {
	console.log(`[${lang}] Loaded ${posts.length} posts for library`);
}

const categories = [
	{ id: 'technical-analysis', label: t('cat.technical-analysis'), full: t('cat.technical-analysis.full') },
	{ id: 'crypto', label: t('cat.crypto'), full: t('cat.crypto.full') },
	{ id: 'algo-trading', label: t('cat.algo-trading'), full: t('cat.algo-trading.full') },
	{ id: 'fundamental-analysis', label: t('cat.fundamental-analysis'), full: t('cat.fundamental-analysis.full') }
];

const breadcrumbItems = [
	{ label: t('nav.library') }
];
---

<!doctype html>
<html lang={lang}>
	<head>
		<BaseHead title={`${SITE_TITLE} - ${t('nav.library')}`} description={t('home.hero_description')} />
	</head>
	<body>
		<Header />
		<main class="container">
			<div class="library-header">
				<Breadcrumb items={breadcrumbItems} />
				<h1 class="mono responsive-title">> {t('library.title')}</h1>
			</div>
			
			<section class="posts-grid fade-in" id="postsGrid">
				<div class="search-and-filter">
					<div class="search-bar">
						<input type="text" placeholder={t('library.search')} id="searchInput" />
					</div>

					<div class="categories-filter">
						<div class="section-label">{t('library.filter')}</div>
						<div class="categories-container categories-container-with-margin" role="group">
							{categories.map(cat => (
								<button 
									class="tag-btn tag-btn-with-icon" 
									data-cat={cat.id} 
									aria-pressed="false"
									title={cat.full}
									type="button"
								>
									<PixelIcon icon={cat.id === 'technical-analysis' ? 'analysis' : cat.id === 'crypto' ? 'crypto' : cat.id === 'algo-trading' ? 'algo' : 'fundamental'} size={12} color="currentColor" />
									[{cat.label}]
								</button>
							))}
						</div>
					</div>
				</div>
				{sortedPosts.length > 0 ? (
					<div id="postsList" class="posts-list">
						{sortedPosts.map((post) => (
							<a 
								href={`/${lang}/library/${post.id}/`} 
								class="post-card" 
								data-title={post.data.title.toLowerCase()}
								data-description={post.data.description.toLowerCase()}
								data-category={post.data.category || ''}
								data-tags={post.data.tags?.join(',').toLowerCase() || ''}
							>
								<Banner 
									title={post.data.title} 
									subtitle={post.data.description}
									category={post.data.category} 
									type="preview" 
								/>
								<div class="post-meta-wrap">
									<div class="post-meta">
										<span><FormattedDate date={post.data.pubDate} /></span>
									</div>
								</div>
								<div class="read-more-link" aria-hidden="true">> {t('library.read_more')}</div>
							</a>
						))}
					</div>
				) : (
					<div class="no-posts" style="padding: var(--space-6); text-align: center; color: var(--color-text-secondary);">
						<p>Статьи не найдены. Проверьте консоль браузера для диагностики.</p>
					</div>
				)}
			</section>

			<div class="pagination-container" id="pagination">
				<!-- Buttons will be injected by script -->
			</div>
			
			<div id="noResults" class="no-results">
				> {t('library.no_results')}
			</div>
			<ScrollTop />
		</main>
		<Footer />

		<script>
			import Fuse from 'fuse.js';

			// Ждём загрузки DOM
			document.addEventListener('DOMContentLoaded', () => {
				const searchInput = document.getElementById('searchInput') as HTMLInputElement;
				const postCards = document.querySelectorAll('.post-card') as NodeListOf<HTMLElement>;
				const noResults = document.getElementById('noResults');
				const categoryButtons = document.querySelectorAll('.tag-btn[data-cat]');

				if (!postCards.length) {
					console.warn('No post cards found');
					return;
				}

				// Нормализуем данные для поиска (все в нижнем регистре, убираем лишние пробелы)
				const postsData = Array.from(postCards).map(card => {
					const title = (card.getAttribute('data-title') || '').toLowerCase().trim();
					const description = (card.getAttribute('data-description') || '').toLowerCase().trim();
					const tags = (card.getAttribute('data-tags') || '').toLowerCase().trim();
					return {
						id: card.getAttribute('href'),
						title: title,
						description: description,
						category: card.getAttribute('data-category') || '',
						tags: tags,
						element: card
					};
				});

				const fuse = new Fuse(postsData, {
					keys: [
						{ name: 'title', weight: 0.6 },
						{ name: 'description', weight: 0.3 },
						{ name: 'tags', weight: 0.1 }
					],
					threshold: 0.2, // Более низкий порог для лучшего поиска коротких запросов
					distance: 100,
					ignoreLocation: true,
					// Поддержка кириллицы и других языков
					includeScore: true,
					minMatchCharLength: 1,
					// Включаем поиск по подстрокам для лучшей работы с кириллицей
					findAllMatches: false,
					shouldSort: true
				});

				let activeCategory = null;
				let searchTerm = '';
				let currentPage = 1;
				const postsPerPage = 6;

				function updateDisplay() {
					let filtered = postsData;

					if (activeCategory) {
						filtered = filtered.filter(p => p.category === activeCategory);
					}

					if (searchTerm && searchTerm.trim()) {
						const searchLower = searchTerm.toLowerCase().trim();
						
						// Сначала пробуем точный поиск по подстроке (быстрее и точнее для коротких запросов)
						const exactMatches = filtered.filter(p => 
							p.title.includes(searchLower) ||
							p.description.includes(searchLower) ||
							p.tags.includes(searchLower)
						);
						
						// Если точных совпадений нет или их мало, используем Fuse.js для нечёткого поиска
						if (exactMatches.length > 0) {
							filtered = exactMatches;
						} else {
							try {
								const results = fuse.search(searchLower);
								const resultIds = new Set(results.map(r => r.item.id));
								filtered = filtered.filter(p => resultIds.has(p.id));
							} catch (error) {
								console.error('Search error:', error);
								// Fallback: простой поиск по подстроке
								filtered = filtered.filter(p => 
									p.title.includes(searchLower) ||
									p.description.includes(searchLower) ||
									p.tags.includes(searchLower)
								);
							}
						}
					}

					const totalPages = Math.ceil(filtered.length / postsPerPage);
					if (currentPage > totalPages) currentPage = Math.max(1, totalPages);

					const startIdx = (currentPage - 1) * postsPerPage;
					const endIdx = startIdx + postsPerPage;
					const pagedPosts = filtered.slice(startIdx, endIdx);
					const pagedIds = new Set(pagedPosts.map(p => p.id));

					let visibleCount = 0;
					postCards.forEach(card => {
						const cardHref = card.getAttribute('href');
						const isVisible = pagedIds.has(cardHref);
						card.style.display = isVisible ? 'flex' : 'none';
						if (isVisible) visibleCount++;
					});

					renderPagination(totalPages);

					if (noResults) noResults.style.display = filtered.length === 0 ? 'block' : 'none';
				}

				function renderPagination(totalPages) {
					const container = document.getElementById('pagination');
					if (!container) return;
					
					if (totalPages <= 1) {
						container.innerHTML = '';
						return;
					}

					let html = '';
					for (let i = 1; i <= totalPages; i++) {
						html += `
							<button class="tag-btn ${i === currentPage ? 'active' : ''}" data-page="${i}">
								${i}
							</button>
						`;
					}
					container.innerHTML = html;

					container.querySelectorAll('[data-page]').forEach(btn => {
						btn.addEventListener('click', () => {
							currentPage = parseInt(btn.getAttribute('data-page') || '1');
							updateDisplay();
							window.scrollTo({ top: 0, behavior: 'smooth' });
						});
					});
				}

				searchInput?.addEventListener('input', (e) => {
					searchTerm = (e.target as HTMLInputElement).value;
					currentPage = 1;
					updateDisplay();
				});

				// Handle search/category filter from URL
				const urlParams = new URLSearchParams(window.location.search);
				const catParam = urlParams.get('cat');
				const searchParam = urlParams.get('search');

				if (catParam) {
					activeCategory = catParam;
					const btn = document.querySelector(`.tag-btn[data-cat="${catParam}"]`);
					if (btn) btn.classList.add('active');
				}

				if (searchParam) {
					searchTerm = searchParam;
					if (searchInput) searchInput.value = searchParam;
				}

				if (catParam || searchParam) {
					updateDisplay();
				}

				categoryButtons.forEach(btn => {
					btn.addEventListener('click', () => {
						const cat = btn.getAttribute('data-cat');
						if (activeCategory === cat) {
							activeCategory = null;
							btn.classList.remove('active');
						} else {
							categoryButtons.forEach(b => b.classList.remove('active'));
							activeCategory = cat;
							btn.classList.add('active');
						}
						currentPage = 1;
						updateDisplay();
					});
				});

				// Initial run to ensure correct state
				updateDisplay();
			});
		</script>
<style>
	.responsive-title {
		font-size: clamp(1.5rem, 5vw, 2.5rem);
		word-break: break-word;
		line-height: 1.2;
	}
	@media (max-width: 480px) {
		.responsive-title {
			font-size: 1.25rem;
		}
	}
</style>
	</body>
</html>
