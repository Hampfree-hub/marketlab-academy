---
import { getCollection } from 'astro:content';
import BaseHead from '../../../components/BaseHead.astro';
import Header from '../../../components/Header.astro';
import Footer from '../../../components/Footer.astro';
import Breadcrumb from '../../../components/Breadcrumb.astro';
import { SITE_TITLE } from '../../../consts';
import FormattedDate from '../../../components/FormattedDate.astro';
import ScrollTop from '../../../components/ScrollTop.astro';
import Banner from '../../../components/Banner.astro';
import PixelIcon from '../../../components/ui/PixelIcon.astro';
import '../../../styles/components/blog-index.css';
import { ui } from '../../../i18n/ui';
import { useTranslations, useTranslatedPath } from '../../../i18n/utils';

export async function getStaticPaths() {
  return [
    { params: { lang: 'ru' } },
    { params: { lang: 'en' } },
    { params: { lang: 'es' } },
  ];
}

const { lang } = Astro.params;
const t = useTranslations(lang as keyof typeof ui);
const translatePath = useTranslatedPath(lang as keyof typeof ui);

// Fetch only posts for current language
const collectionName = `blog-${lang}` as 'blog-ru' | 'blog-en' | 'blog-es';
const posts = await getCollection(collectionName).catch((err) => {
	console.error(`Error loading posts for ${collectionName}:`, err);
	return [];
});

// üîí –£–ë–ò–†–ê–ï–ú –î–£–ë–õ–ò–ö–ê–¢–´: –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º post.id –∏ —É–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
const normalizePostId = (id: string) => id.replace(/\/index$/, '').replace(/\/+$/, '');

// –î–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è: –∏—Å–ø–æ–ª—å–∑—É–µ–º Map –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏
const seenIds = new Map<string, number>();
const uniquePosts: typeof posts = [];

posts.forEach((post, index) => {
	const normalizedId = normalizePostId(post.id);
	
	if (seenIds.has(normalizedId)) {
		// –î—É–±–ª–∏–∫–∞—Ç - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
		return;
	}
	
	seenIds.set(normalizedId, index);
	// –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç —Å –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–º id (–Ω–µ –º—É—Ç–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª)
	uniquePosts.push({
		...post,
		id: normalizedId
	} as typeof post);
});

const sortedPosts = uniquePosts.sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

// Debug: Log posts count
const duplicateCount = posts.length - uniquePosts.length;
if (duplicateCount > 0) {
	console.warn(`[${lang}] Removed ${duplicateCount} duplicate posts (${posts.length} ‚Üí ${uniquePosts.length})`);
	// –õ–æ–≥–∏—Ä—É–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
	const allIds = posts.map(p => ({ original: p.id, normalized: normalizePostId(p.id) }));
	const duplicates = allIds.filter((item, idx, arr) => 
		arr.findIndex(i => normalizePostId(i.original) === item.normalized) !== idx
	);
	if (duplicates.length > 0) {
		console.warn(`[${lang}] Duplicate IDs found:`, duplicates);
	}
}

const categories = [
	{ id: 'technical-analysis', label: t('cat.technical-analysis'), full: t('cat.technical-analysis.full') },
	{ id: 'crypto', label: t('cat.crypto'), full: t('cat.crypto.full') },
	{ id: 'algo-trading', label: t('cat.algo-trading'), full: t('cat.algo-trading.full') },
	{ id: 'fundamental-analysis', label: t('cat.fundamental-analysis'), full: t('cat.fundamental-analysis.full') }
];

const breadcrumbItems = [
	{ label: t('nav.library') }
];
---

<!doctype html>
<html lang={lang}>
	<head>
		<BaseHead title={`${SITE_TITLE} - ${t('nav.library')}`} description={t('home.hero_description')} />
	</head>
	<body>
		<Header />
		<main class="container">
			<div class="library-header">
				<Breadcrumb items={breadcrumbItems} />
				<h1 class="mono responsive-title">> {t('library.title')}</h1>
			</div>
			
			<section class="posts-grid fade-in" id="postsGrid">
				<div class="search-and-filter">
					<div class="search-bar">
						<input type="text" placeholder={t('library.search')} id="searchInput" />
					</div>

					<div class="categories-filter">
						<div class="section-label">{t('library.filter')}</div>
						<div class="categories-container categories-container-with-margin" role="group">
							{categories.map(cat => (
								<button 
									class="tag-btn tag-btn-with-icon" 
									data-cat={cat.id} 
									aria-pressed="false"
									title={cat.full}
									type="button"
								>
									<PixelIcon icon={cat.id === 'technical-analysis' ? 'analysis' : cat.id === 'crypto' ? 'crypto' : cat.id === 'algo-trading' ? 'algo' : 'fundamental'} size={12} color="currentColor" />
									[{cat.label}]
								</button>
							))}
						</div>
					</div>
				</div>
				{sortedPosts.length > 0 ? (
					<div id="postsList" class="posts-list">
						{sortedPosts.map((post) => (
							<a 
								href={`/${lang}/library/${post.id}/`} 
								class="post-card" 
								data-title={post.data.title.toLowerCase()}
								data-description={post.data.description.toLowerCase()}
								data-category={post.data.category || ''}
								data-tags={post.data.tags?.join(',').toLowerCase() || ''}
							>
								<Banner 
									title={post.data.title} 
									subtitle={post.data.description}
									category={post.data.category} 
									type="preview" 
								/>
								<div class="post-meta-wrap">
									<div class="post-meta">
										<span><FormattedDate date={post.data.pubDate} /></span>
									</div>
								</div>
								<div class="read-more-link" aria-hidden="true">> {t('library.read_more')}</div>
							</a>
						))}
					</div>
				) : (
					<div class="no-posts" style="padding: var(--space-6); text-align: center; color: var(--color-text-secondary);">
						<p>–°—Ç–∞—Ç—å–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏.</p>
					</div>
				)}
			</section>

			<div class="pagination-container" id="pagination">
				<!-- Buttons will be injected by script -->
			</div>
			
			<div id="noResults" class="no-results">
				> {t('library.no_results')}
			</div>
			<ScrollTop />
		</main>
		<Footer />

		<script>
			import Fuse from 'fuse.js';

			// –ñ–¥—ë–º –∑–∞–≥—Ä—É–∑–∫–∏ DOM
			document.addEventListener('DOMContentLoaded', () => {
				const searchInput = document.getElementById('searchInput') as HTMLInputElement;
				const postCards = document.querySelectorAll('.post-card') as NodeListOf<HTMLElement>;
				const noResults = document.getElementById('noResults');
				const categoryButtons = document.querySelectorAll('.tag-btn[data-cat]');

				if (!postCards.length) {
					console.warn('No post cards found');
					return;
				}

				// –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ (–≤—Å–µ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, —É–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã)
				const postsDataRaw = Array.from(postCards).map(card => {
					const title = (card.getAttribute('data-title') || '').toLowerCase().trim();
					const description = (card.getAttribute('data-description') || '').toLowerCase().trim();
					const tags = (card.getAttribute('data-tags') || '').toLowerCase().trim();
					return {
						id: card.getAttribute('href'),
						title: title,
						description: description,
						category: card.getAttribute('data-category') || '',
						tags: tags,
						element: card
					};
				});
				
				// üîí –î–ï–î–£–ü–õ–ò–ö–ê–¶–ò–Ø –ù–ê –ö–õ–ò–ï–ù–¢–ï: —É–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ id (href)
				const seenHrefs = new Set<string>();
				const postsData = postsDataRaw.filter(p => {
					if (seenHrefs.has(p.id)) {
						console.warn(`[Client] Duplicate card detected: ${p.id}. Hiding duplicate.`);
						// –°–∫—Ä—ã–≤–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç —Å—Ä–∞–∑—É
						if (p.element) p.element.style.display = 'none';
						return false;
					}
					seenHrefs.add(p.id);
					return true;
				});
				
				if (postsDataRaw.length !== postsData.length) {
					console.warn(`[Client] Removed ${postsDataRaw.length - postsData.length} duplicate cards from DOM`);
				}

				const fuse = new Fuse(postsData, {
					keys: [
						{ name: 'title', weight: 0.6 },
						{ name: 'description', weight: 0.3 },
						{ name: 'tags', weight: 0.1 }
					],
					threshold: 0.2, // –ë–æ–ª–µ–µ –Ω–∏–∑–∫–∏–π –ø–æ—Ä–æ–≥ –¥–ª—è –ª—É—á—à–µ–≥–æ –ø–æ–∏—Å–∫–∞ –∫–æ—Ä–æ—Ç–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
					distance: 100,
					ignoreLocation: true,
					// –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∫–∏—Ä–∏–ª–ª–∏—Ü—ã –∏ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–æ–≤
					includeScore: true,
					minMatchCharLength: 1,
					// –í–∫–ª—é—á–∞–µ–º –ø–æ–∏—Å–∫ –ø–æ –ø–æ–¥—Å—Ç—Ä–æ–∫–∞–º –¥–ª—è –ª—É—á—à–µ–π —Ä–∞–±–æ—Ç—ã —Å –∫–∏—Ä–∏–ª–ª–∏—Ü–µ–π
					findAllMatches: false,
					shouldSort: true
				});

				let activeCategory: string | null = null;
				let searchTerm = '';
				let currentPage = 1;
				const postsPerPage = 6;

				function updateDisplay() {
					let filtered = postsData;

					if (activeCategory) {
						filtered = filtered.filter(p => p.category === activeCategory);
					}

					if (searchTerm && searchTerm.trim()) {
						const searchLower = searchTerm.toLowerCase().trim();
						
						// –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ –ø–æ–¥—Å—Ç—Ä–æ–∫–µ (–±—ã—Å—Ç—Ä–µ–µ –∏ —Ç–æ—á–Ω–µ–µ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤)
						const exactMatches = filtered.filter(p => 
							p.title.includes(searchLower) ||
							p.description.includes(searchLower) ||
							p.tags.includes(searchLower)
						);
						
						// –ï—Å–ª–∏ —Ç–æ—á–Ω—ã—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ—Ç –∏–ª–∏ –∏—Ö –º–∞–ª–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º Fuse.js –¥–ª—è –Ω–µ—á—ë—Ç–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞
						if (exactMatches.length > 0) {
							filtered = exactMatches;
						} else {
							try {
								const results = fuse.search(searchLower);
								const resultIds = new Set(results.map(r => r.item.id));
								filtered = filtered.filter(p => resultIds.has(p.id));
							} catch (error) {
								console.error('Search error:', error);
								// Fallback: –ø—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫ –ø–æ –ø–æ–¥—Å—Ç—Ä–æ–∫–µ
								filtered = filtered.filter(p => 
									p.title.includes(searchLower) ||
									p.description.includes(searchLower) ||
									p.tags.includes(searchLower)
								);
							}
						}
					}

					const totalPages = Math.ceil(filtered.length / postsPerPage);
					if (currentPage > totalPages) currentPage = Math.max(1, totalPages);

					const startIdx = (currentPage - 1) * postsPerPage;
					const endIdx = startIdx + postsPerPage;
					const pagedPosts = filtered.slice(startIdx, endIdx);
					const pagedIds = new Set(pagedPosts.map(p => p.id));

					let visibleCount = 0;
					postCards.forEach(card => {
						const cardHref = card.getAttribute('href');
						const isVisible = pagedIds.has(cardHref);
						card.style.display = isVisible ? 'flex' : 'none';
						if (isVisible) visibleCount++;
					});

					renderPagination(totalPages);

					if (noResults) noResults.style.display = filtered.length === 0 ? 'block' : 'none';
				}

				function renderPagination(totalPages: number) {
					const container = document.getElementById('pagination');
					if (!container) return;
					
					if (totalPages <= 1) {
						container.innerHTML = '';
						return;
					}

					let html = '';
					for (let i = 1; i <= totalPages; i++) {
						html += `
							<button class="tag-btn ${i === currentPage ? 'active' : ''}" data-page="${i}">
								${i}
							</button>
						`;
					}
					container.innerHTML = html;

					container.querySelectorAll('[data-page]').forEach(btn => {
						btn.addEventListener('click', () => {
							currentPage = parseInt(btn.getAttribute('data-page') || '1');
							updateDisplay();
							window.scrollTo({ top: 0, behavior: 'smooth' });
						});
					});
				}

				searchInput?.addEventListener('input', (e) => {
					searchTerm = (e.target as HTMLInputElement).value;
					currentPage = 1;
					updateDisplay();
				});

				// Handle search/category filter from URL
				const urlParams = new URLSearchParams(window.location.search);
				const catParam = urlParams.get('cat');
				const searchParam = urlParams.get('search');

				if (catParam) {
					activeCategory = catParam;
					const btn = document.querySelector(`.tag-btn[data-cat="${catParam}"]`);
					if (btn) btn.classList.add('active');
				}

				if (searchParam) {
					searchTerm = searchParam;
					if (searchInput) searchInput.value = searchParam;
				}

				if (catParam || searchParam) {
					updateDisplay();
				}

				categoryButtons.forEach(btn => {
					btn.addEventListener('click', () => {
						const cat = btn.getAttribute('data-cat');
						if (activeCategory === cat) {
							activeCategory = null;
							btn.classList.remove('active');
						} else {
							categoryButtons.forEach(b => b.classList.remove('active'));
							activeCategory = cat;
							btn.classList.add('active');
						}
						currentPage = 1;
						updateDisplay();
					});
				});

				// Initial run to ensure correct state
				updateDisplay();
			});
		</script>
<style>
	.responsive-title {
		font-size: clamp(1.5rem, 5vw, 2.5rem);
		word-break: break-word;
		line-height: 1.2;
	}
	@media (max-width: 480px) {
		.responsive-title {
			font-size: 1.25rem;
		}
	}
</style>
	</body>
</html>
